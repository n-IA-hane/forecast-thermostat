# =============================================================================
# ESPHome Smart Thermostat with Weather Forecast Display
# =============================================================================
#
# A feature-rich ESP32-based thermostat with ILI9341 touchscreen display,
# integrating Home Assistant for weather forecasts, alarm control, and
# power consumption monitoring.
#
# Hardware Requirements:
#   - ESP32 development board
#   - ILI9341 320x240 TFT display with XPT2046 touch controller
#   - BME280 temperature/humidity/pressure sensor
#   - PIR motion sensor (optional)
#   - Piezo buzzer for RTTTL tones (optional)
#
# Home Assistant Integration:
#   - Weather entity for current conditions and forecasts
#   - Heater switch control via Shelly relay
#   - Alarm control panel integration
#   - Power consumption monitoring sensors
#
# =============================================================================

esphome:
  name: forecast-thermostat-32x24
  on_boot:
    - display.page.show: init_page
    - delay: 2s
    - display.page.show: termostato_page

esp32:
  board: esp32dev
  framework:
    type: arduino

# =============================================================================
# Configuration Substitutions
# =============================================================================
# Centralized configuration variables for easy customization.
# Modify these values to match your Home Assistant entity IDs.

substitutions:
  heater: switch.shelly_caldaia             # Home Assistant heater switch entity
  weather_entity: weather.casa              # Home Assistant weather entity
  forecast_interval: 5min                   # Weather forecast update interval
  tc: sensor.consumo_totale_power           # Total household power consumption sensor
  pc: sensor.consumo_cantina_power          # Secondary power consumption sensor (e.g., laundry room)
  alarm_entity: alarm_control_panel.allarme # Home Assistant alarm control panel entity
  icon_xy: '60x60'                          # Weather icon dimensions (width x height)

# =============================================================================
# Logging Configuration
# =============================================================================

logger:
  level: ERROR

# =============================================================================
# Home Assistant API Configuration
# =============================================================================
# Exposes a custom service for playing RTTTL ringtones via Home Assistant.

api:
  on_client_connected:
    - delay: 5s
    - script.execute: fetch_forecast
  services:
    - service: play_rtttl
      variables:
        song_str: string
      then:
        - rtttl.play:
            rtttl: !lambda 'return song_str;'

# =============================================================================
# RTTTL Buzzer Configuration
# =============================================================================

rtttl:
  output: rtttl_out

# =============================================================================
# OTA Updates
# =============================================================================

ota:
  platform: esphome

# =============================================================================
# WiFi Configuration
# =============================================================================
# Static IP configuration with fallback Access Point mode for initial setup.

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  manual_ip:
    static_ip: 192.168.1.15
    gateway: 192.168.1.1
    subnet: 255.255.255.0
  ap:
    ssid: "Weather-thermostat"
    password: !secret fallpass

captive_portal:

# =============================================================================
# JSON Component
# =============================================================================
# Required for parsing weather forecast JSON responses from Home Assistant.

json:

# =============================================================================
# SPI Bus Configuration
# =============================================================================
# Used by the ILI9341 display and XPT2046 touch controller.

spi:
  clk_pin: 18
  mosi_pin: 23
  miso_pin: 19

# =============================================================================
# I2C Bus Configuration
# =============================================================================
# Used by the BME280 environmental sensor.

i2c:
  - id: bus_a
    sda: 32
    scl: 25

# =============================================================================
# Climate/Thermostat Configuration
# =============================================================================
# Bang-bang thermostat controller using BME280 temperature readings.
# Controls heating via Home Assistant switch entity.

climate:
  - platform: thermostat
    visual:
      min_temperature: 16 °C
      max_temperature: 30 °C
    name: Termostato
    id: termostato1
    sensor: temp_int
    min_heating_off_time: 30s
    min_heating_run_time: 30s
    min_idle_time: 30s
    heat_action:
      homeassistant.service:
        service: switch.turn_on
        data:
          entity_id: $heater
    idle_action:
      homeassistant.service:
        service: switch.turn_off
        data:
          entity_id: $heater

# =============================================================================
# Touchscreen Configuration
# =============================================================================
# XPT2046 resistive touch controller with calibration values.
# Touch events trigger backlight wake-up.

touchscreen:
  platform: xpt2046
  id: xpt2046_touch
  cs_pin: 14
  transform:
    mirror_x: true
    mirror_y: true
    swap_xy: true
  calibration:
    x_min: 380
    x_max: 3800
    y_min: 370
    y_max: 3900
  on_touch:
    - script.stop: backlight_timer
    - script.execute: backlight_timer

# =============================================================================
# PWM Output Configuration
# =============================================================================

output:
  # Display backlight PWM control
  - platform: ledc
    pin: 15
    id: backlight_pwm
    inverted: true

  # RTTTL buzzer output
  - platform: ledc
    pin: GPIO21
    id: rtttl_out

# =============================================================================
# Backlight Control
# =============================================================================
# Monochromatic light component for display backlight brightness control.

light:
  - platform: monochromatic
    output: backlight_pwm
    name: "Thermostat Light"
    id: back_light
    restore_mode: ALWAYS_ON
    internal: true

# =============================================================================
# Scripts
# =============================================================================

script:
  # ---------------------------------------------------------------------------
  # Backlight Auto-Dimming Timer
  # ---------------------------------------------------------------------------
  # Implements automatic backlight dimming to save power:
  # - Full brightness for 20 seconds after interaction
  # - 50% brightness for additional 40 seconds
  # - Off after total 60 seconds of inactivity

  - id: backlight_timer
    then:
      - light.turn_on:
          id: back_light
          brightness: 100%
      - delay: 20s
      - light.turn_on:
          id: back_light
          brightness: 50%
      - delay: 40s
      - light.turn_off: back_light

  # ---------------------------------------------------------------------------
  # Weather Forecast Fetcher
  # ---------------------------------------------------------------------------
  # Retrieves 5-day weather forecast from Home Assistant using the
  # weather.get_forecasts action. Parses the JSON response and stores
  # forecast data in global variables for display rendering.

  - id: fetch_forecast
    then:
      - homeassistant.action:
          action: weather.get_forecasts
          data:
            entity_id: $weather_entity
            type: daily
          capture_response: true
          on_success:
            - lambda: |-
                // Parse JSON response structure: response["response"]["entity_id"]["forecast"][n]
                JsonObjectConst weather_response = response["response"];
                if (weather_response.isNull()) {
                  ESP_LOGE("forecast", "Invalid response structure");
                  return;
                }

                JsonObjectConst weather_data = weather_response["${weather_entity}"];
                if (weather_data.isNull()) {
                  ESP_LOGE("forecast", "Weather entity ${weather_entity} not found in response");
                  return;
                }

                JsonArrayConst forecast = weather_data["forecast"];
                if (forecast.isNull()) {
                  ESP_LOGE("forecast", "Forecast array not found in response");
                  return;
                }

                int count = forecast.size();

                // Populate global forecast variables (indices 1-5)
                for (int i = 0; i < 5 && i < count; i++) {
                  JsonObjectConst day = forecast[i];
                  id(forecast_condition)[i + 1] = day["condition"].as<std::string>();
                  id(forecast_precip)[i + 1]    = day["precipitation"] | 0.0f;
                  id(forecast_temp_max)[i + 1]  = day["temperature"]   | 0.0f;
                  id(forecast_temp_min)[i + 1]  = day["templow"]       | 0.0f;
                }
          on_error:
            - logger.log:
                level: ERROR
                format: "Failed to fetch weather forecast from Home Assistant"

# =============================================================================
# Time Synchronization
# =============================================================================

time:
  - platform: homeassistant
    id: esptime

# =============================================================================
# Periodic Forecast Updates
# =============================================================================

interval:
  - interval: $forecast_interval
    then:
      - script.execute: fetch_forecast

# =============================================================================
# Binary Sensors
# =============================================================================

binary_sensor:
  # ---------------------------------------------------------------------------
  # PIR Motion Sensor
  # ---------------------------------------------------------------------------
  # Triggers backlight wake-up on motion detection.

  - platform: gpio
    pin:
      number: 26
      mode: INPUT_PULLUP
    device_class: motion
    id: movimento
    name: Motion
    on_press:
      - script.stop: backlight_timer
      - script.execute: backlight_timer

  # ---------------------------------------------------------------------------
  # Heater State Sensor
  # ---------------------------------------------------------------------------
  # Mirrors the heater switch state from Home Assistant for local display.

  - platform: homeassistant
    name: "Caldaia"
    entity_id: $heater
    id: sensor_caldaia
    internal: true

  # ---------------------------------------------------------------------------
  # Touchscreen Controls - Temperature Adjustment
  # ---------------------------------------------------------------------------

  # Increase target temperature (+0.5°C)
  - platform: touchscreen
    id: touch_key_plus
    x_min: 200
    x_max: 320
    y_min: 150
    y_max: 240
    page_id: termostato_page
    on_press:
      - climate.control:
          id: termostato1
          target_temperature: !lambda 'return (id(termostato1).target_temperature + 0.5);'
      - lambda: 'id(touch_key_plus).publish_state(false);'

  # Decrease target temperature (-0.5°C)
  - platform: touchscreen
    id: touch_key_minus
    x_min: 0
    x_max: 80
    y_min: 150
    y_max: 240
    page_id: termostato_page
    on_press:
      - climate.control:
          id: termostato1
          target_temperature: !lambda 'return (id(termostato1).target_temperature - 0.5);'
      - lambda: 'id(touch_key_minus).publish_state(false);'

  # ---------------------------------------------------------------------------
  # Touchscreen Controls - Climate Mode Toggle
  # ---------------------------------------------------------------------------
  # Short press: Enable HEAT mode
  # Long press (>550ms): Disable thermostat (OFF mode)

  - platform: touchscreen
    id: touch_key_climate
    x_min: 120
    x_max: 200
    y_min: 150
    y_max: 240
    page_id: termostato_page
    on_click:
      - min_length: 0ms
        max_length: 500ms
        then:
          - climate.control:
              id: termostato1
              mode: "HEAT"
      - min_length: 550ms
        max_length: 5000ms
        then:
          - climate.control:
              id: termostato1
              mode: "OFF"

  # ---------------------------------------------------------------------------
  # Touchscreen Controls - Page Navigation
  # ---------------------------------------------------------------------------

  # Navigate to next page (skips initialization page)
  - platform: touchscreen
    id: touch_key_next
    x_min: 200
    x_max: 320
    y_min: 0
    y_max: 80
    on_press:
      - lambda: |-
          id(tft_ha).show_next_page();
          // Skip init_page when navigating
          if (id(tft_ha).get_active_page() == id(init_page)) {
            id(tft_ha).show_next_page();
          }
      - lambda: 'id(touch_key_next).publish_state(false);'

  # Navigate to previous page (skips initialization page)
  - platform: touchscreen
    id: touch_key_previous
    page_id: termostato_page
    x_min: 0
    x_max: 80
    y_min: 0
    y_max: 80
    on_press:
      - lambda: |-
          id(tft_ha).show_prev_page();
          // Skip init_page when navigating
          if (id(tft_ha).get_active_page() == id(init_page)) {
            id(tft_ha).show_prev_page();
          }
      - lambda: 'id(touch_key_previous).publish_state(false);'

  # ---------------------------------------------------------------------------
  # Touchscreen Controls - Alarm Panel
  # ---------------------------------------------------------------------------

  # Arm alarm in Home mode
  - platform: touchscreen
    id: touch_key_home
    page_id: alarm_cp_page
    x_min: 0
    x_max: 160
    y_min: 0
    y_max: 80
    on_press:
      - homeassistant.service:
          service: alarm_control_panel.alarm_arm_home
          data:
            entity_id: $alarm_entity
      - lambda: 'id(touch_key_home).publish_state(false);'

  # Arm alarm in Away mode
  - platform: touchscreen
    id: touch_key_away
    page_id: alarm_cp_page
    x_min: 0
    x_max: 160
    y_min: 80
    y_max: 160
    on_press:
      - homeassistant.service:
          service: alarm_control_panel.alarm_arm_away
          data:
            entity_id: $alarm_entity
      - lambda: 'id(touch_key_away).publish_state(false);'

  # Disarm alarm
  - platform: touchscreen
    id: touch_key_disarm
    page_id: alarm_cp_page
    x_min: 0
    x_max: 160
    y_min: 160
    y_max: 240
    on_press:
      - homeassistant.service:
          service: alarm_control_panel.alarm_disarm
          data:
            entity_id: $alarm_entity
            code: "1234"
      - lambda: 'id(touch_key_disarm).publish_state(false);'

# =============================================================================
# Button Component
# =============================================================================

button:
  - platform: template
    name: Next page
    on_press:
      - display.page.show_next: tft_ha

# =============================================================================
# Sensors
# =============================================================================

sensor:
  # ---------------------------------------------------------------------------
  # Weather Data from Home Assistant
  # ---------------------------------------------------------------------------

  - platform: homeassistant
    id: weather_temperature
    entity_id: $weather_entity
    attribute: temperature
    internal: true

  - platform: homeassistant
    id: vento
    entity_id: $weather_entity
    attribute: wind_speed
    internal: true

  - platform: homeassistant
    id: umidita_ext
    entity_id: $weather_entity
    attribute: humidity
    internal: true

  # ---------------------------------------------------------------------------
  # BME280 Environmental Sensor
  # ---------------------------------------------------------------------------
  # Provides indoor temperature (used for thermostat), pressure, and humidity.

  - platform: bme280_i2c
    address: 0x76
    temperature:
      name: "Temperature"
      id: temp_int
      oversampling: 16x
    pressure:
      name: "Pressure"
      id: pressione_int
    humidity:
      name: "Humidity"
      id: umidita_int
    update_interval: 20s

  # ---------------------------------------------------------------------------
  # Power Consumption Sensors from Home Assistant
  # ---------------------------------------------------------------------------

  - platform: homeassistant
    id: consumo_t
    entity_id: $tc
    internal: true

  - platform: homeassistant
    id: consumo_c
    entity_id: $pc
    internal: true

# =============================================================================
# Text Sensors
# =============================================================================

text_sensor:
  - platform: homeassistant
    id: weather_location
    entity_id: $weather_entity
    attribute: friendly_name
    internal: true

  - platform: homeassistant
    id: weather_condition
    entity_id: $weather_entity
    internal: true

  - platform: homeassistant
    name: "Alarm Status"
    entity_id: $alarm_entity
    id: stato_allarme

# =============================================================================
# Weather Icon Images
# =============================================================================
# PNG images mapped to Home Assistant weather conditions.

image:
  - file: "images/0-default.png"
    id: wpng_0
    type: RGB
    resize: ${icon_xy}
  - file: "images/1-clear-night.png"
    id: wpng_1
    type: RGB
    resize: ${icon_xy}
  - file: "images/2-cloudy.png"
    id: wpng_2
    type: RGB
    resize: ${icon_xy}
  - file: "images/3-fog.png"
    id: wpng_3
    type: RGB
    resize: ${icon_xy}
  - file: "images/4-hail.png"
    id: wpng_4
    type: RGB
    resize: ${icon_xy}
  - file: "images/5-lightning.png"
    id: wpng_5
    type: RGB
    resize: ${icon_xy}
  - file: "images/6-lightning-rainy.png"
    id: wpng_6
    type: RGB
    resize: ${icon_xy}
  - file: "images/7-partlycloudy.png"
    id: wpng_7
    type: RGB
    resize: ${icon_xy}
  - file: "images/8-pouring.png"
    id: wpng_8
    type: RGB
    resize: ${icon_xy}
  - file: "images/9-rainy.png"
    id: wpng_9
    type: RGB
    resize: ${icon_xy}
  - file: "images/10-snowy.png"
    id: wpng_10
    type: RGB
    resize: ${icon_xy}
  - file: "images/11-snowy-rainy.png"
    id: wpng_11
    type: RGB
    resize: ${icon_xy}
  - file: "images/12-sunny.png"
    id: wpng_12
    type: RGB
    resize: ${icon_xy}
  - file: "images/13-windy.png"
    id: wpng_13
    type: RGB
    resize: ${icon_xy}
  - file: "images/14-windy-variant.png"
    id: wpng_14
    type: RGB
    resize: ${icon_xy}
  - file: "images/15-exceptional.png"
    id: wpng_15
    type: RGB
    resize: ${icon_xy}

# =============================================================================
# Color Definitions
# =============================================================================

color:
  - id: my_red
    red: 100%
    green: 0%
    blue: 0%
  - id: my_yellow
    red: 100%
    green: 100%
    blue: 0%
  - id: my_green
    red: 0%
    green: 100%
    blue: 0%
  - id: my_blue
    red: 0%
    green: 0%
    blue: 100%
  - id: my_gray
    red: 50%
    green: 50%
    blue: 50%

# =============================================================================
# Font Definitions
# =============================================================================
# Uses Google Fonts (Roboto family) and Material Design Icons.

font:
  - file:
      type: gfonts
      family: Roboto
      weight: 700
    size: 18
    id: font_date

  - file:
      type: gfonts
      family: Roboto
      weight: 700
    size: 38
    id: font_temp

  - file:
      type: gfonts
      family: Roboto
    size: 14
    id: font_location

  - file:
      type: gfonts
      family: Roboto
      weight: 900
    size: 12
    id: font_day

  - file:
      type: gfonts
      family: "Roboto Mono"
    size: 12
    bpp: 4
    id: font_forecast

  # Sensor display font with MDI icons
  - file:
      type: gfonts
      family: Roboto
    size: 14
    id: sensor_font
    bpp: 4
    extras:
      - file: "https://github.com/Templarian/MaterialDesign-Webfont/raw/master/fonts/materialdesignicons-webfont.ttf"
        glyphs: [
          "\U000F059D",  # mdi:weather-windy
          "\U000F050F",  # mdi:thermometer
          "\U000F04C5",  # mdi:gauge
          "\U000F058E",  # mdi:water-percent
          "\U000F0238",  # mdi:fire
          "\U000F0F55",  # mdi:home-thermometer
        ]

  # Large symbol font for status icons
  - file: "https://github.com/Templarian/MaterialDesign-Webfont/raw/master/fonts/materialdesignicons-webfont.ttf"
    id: symbols_font
    size: 50
    glyphs:
      - "\U000F0238"  # mdi:fire
      - "\U000F072A"  # mdi:washing-machine
      - "\U000F11BD"  # mdi:washing-machine-off
      - "\U000F0241"  # mdi:flash
      - "\U000F0EF7"  # mdi:flash-alert
      - "\U000F06D0"  # mdi:eye
      - "\U000F0425"  # mdi:power
      - "\U000F0415"  # mdi:plus
      - "\U000F0374"  # mdi:minus
      - "\U000F099E"  # mdi:shield-off
      - "\U000F099D"  # mdi:shield-lock
      - "\U000F068A"  # mdi:shield-home
      - "\U000F0780"  # mdi:shield-half-full
      - "\U000F0ECC"  # mdi:shield-alert
      - "\U000F0590"  # mdi:weather-cloudy
      - "\U000F0591"  # mdi:weather-fog
      - "\U000F0592"  # mdi:weather-hail
      - "\U000F0593"  # mdi:weather-lightning
      - "\U000F067E"  # mdi:weather-lightning-rainy
      - "\U000F0594"  # mdi:weather-night
      - "\U000F0595"  # mdi:weather-partly-cloudy
      - "\U000F0596"  # mdi:weather-pouring
      - "\U000F0597"  # mdi:weather-rainy
      - "\U000F0598"  # mdi:weather-snowy
      - "\U000F067F"  # mdi:weather-snowy-rainy
      - "\U000F0599"  # mdi:weather-sunny
      - "\U000F059D"  # mdi:weather-windy
      - "\U000F059E"  # mdi:weather-windy-variant

# =============================================================================
# Global Variables
# =============================================================================
# Runtime storage for display layout positions and weather forecast data.

globals:
  # Display grid X positions (32 columns)
  - id: x
    type: int[33]
    restore_value: no
    initial_value: '{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}'

  # Display grid Y positions (24 rows)
  - id: y
    type: int[25]
    restore_value: no
    initial_value: '{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}'

  # X positions for 5-day forecast columns
  - id: x_forecast
    type: int[6]
    restore_value: no
    initial_value: '{0,0,0,0,0,0}'

  # Forecast weather conditions (indices 1-5)
  - id: forecast_condition
    type: std::array<std::string, 6>
    restore_value: no
    initial_value: '{"","","","","",""}'

  # Forecast precipitation values in mm (indices 1-5)
  - id: forecast_precip
    type: float[6]
    restore_value: no
    initial_value: '{0.0,0.0,0.0,0.0,0.0,0.0}'

  # Forecast minimum temperatures (indices 1-5)
  - id: forecast_temp_min
    type: float[6]
    restore_value: no
    initial_value: '{0.0,0.0,0.0,0.0,0.0,0.0}'

  # Forecast maximum temperatures (indices 1-5)
  - id: forecast_temp_max
    type: float[6]
    restore_value: no
    initial_value: '{0.0,0.0,0.0,0.0,0.0,0.0}'

  # Localized day names (Italian, short format)
  - id: day_names
    type: std::array<const char *, 8>
    restore_value: no
    initial_value: '{"", "Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"}'

  # Localized day names (Italian, full format)
  - id: day_names_ext
    type: std::array<const char *, 8>
    restore_value: no
    initial_value: '{"", "Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"}'

  # Localized month names (Italian, short format)
  - id: month_names
    type: std::array<const char *, 13>
    restore_value: no
    initial_value: '{"", "Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"}'

# =============================================================================
# Display Configuration
# =============================================================================
# ILI9341 320x240 TFT display with multiple pages.

display:
  - platform: ili9xxx
    model: ili9341
    cs_pin: 5
    dc_pin: 4
    reset_pin: 22
    id: tft_ha
    invert_colors: false
    color_palette: 8BIT
    transform:
      swap_xy: true
      mirror_x: false
      mirror_y: false
    dimensions:
      height: 240
      width: 320
    on_page_change:
      - to: alarm_cp_page
        then:
          # Auto-return to thermostat page after 60 seconds
          - delay: 60s
          - if:
              condition:
                - display.is_displaying_page: alarm_cp_page
              then:
                - display.page.show: termostato_page

    pages:
      # -----------------------------------------------------------------------
      # Initialization Page
      # -----------------------------------------------------------------------
      # Calculates and stores grid positions for responsive layout.
      # Shown briefly at boot before switching to main thermostat page.

      - id: init_page
        lambda: |-
          int w = it.get_width();
          int h = it.get_height();

          // Calculate grid step sizes
          int step_x = w / 32;
          int step_y = h / 24;
          int step_forecast_x = round(w / 5.0);

          // Populate position arrays
          for (int i = 1; i <= 32; i++) {
            id(x)[i] = step_x * i;
          }
          for (int i = 1; i <= 24; i++) {
            id(y)[i] = step_y * i;
          }

          // Calculate forecast column center positions
          id(x_forecast)[0] = 0;
          for (int i = 1; i <= 5; i++) {
            id(x_forecast)[i] = round((i - 1) * step_forecast_x + step_forecast_x / 2.0);
          }

          // Display initialization message
          it.filled_rectangle(0, 0, w, h, Color::BLACK);
          it.printf(w/2, h/2, id(font_date), TextAlign::CENTER, "Initializing...");

      # -----------------------------------------------------------------------
      # Main Thermostat Page
      # -----------------------------------------------------------------------
      # Displays current weather, indoor/outdoor conditions, 5-day forecast,
      # thermostat status, and power consumption indicators.

      - id: termostato_page
        lambda: |-
          it.filled_rectangle(0, 0, it.get_width(), it.get_height(), Color::BLACK);

          // Day and month name arrays (Italian localization)
          const char *day_array[] = {"", "Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"};
          const char *day_array_ext[] = {"", "Domenica", "Lunedi", "Martedi", "Mercoledi", "Giovedi", "Venerdi", "Sabato"};
          const char *month_array[] = {"", "Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"};

          // Weather condition to image mapping
          static const std::map<std::string, image::Image *> image_dict = {
            {"clear-night", id(wpng_1)},
            {"cloudy", id(wpng_2)},
            {"fog", id(wpng_3)},
            {"hail", id(wpng_4)},
            {"lightning", id(wpng_5)},
            {"lightning-rainy", id(wpng_6)},
            {"partlycloudy", id(wpng_7)},
            {"pouring", id(wpng_8)},
            {"rainy", id(wpng_9)},
            {"snowy", id(wpng_10)},
            {"snowy-rainy", id(wpng_11)},
            {"sunny", id(wpng_12)},
            {"windy", id(wpng_13)},
            {"windy-variant", id(wpng_14)},
            {"exceptional", id(wpng_15)},
            {"", id(wpng_0)}
          };

          // Weather condition to localized description mapping (Italian)
          static const std::map<std::string, const char *> condition_dict = {
            {"clear-night", "Sereno"},
            {"cloudy", "Nuvoloso"},
            {"fog", "Nebbia"},
            {"hail", "Grandine"},
            {"lightning", "Fulmini"},
            {"lightning-rainy", "Fulmini/Pioggia"},
            {"partlycloudy", "Parz. nuvoloso"},
            {"pouring", "Piovoso"},
            {"rainy", "Pioggia"},
            {"snowy", "Neve"},
            {"snowy-rainy", "Neve/Pioggia"},
            {"sunny", "Soleggiato"},
            {"windy", "Ventoso"},
            {"windy-variant", "Vento forte"},
            {"exceptional", "Eccezionale"},
            {"", "Unknown"}
          };

          // Weather condition to MDI icon mapping
          static const std::map<std::string, const char *> icon_dict = {
            {"clear-night", "\U000F0594"},
            {"cloudy", "\U000F0590"},
            {"fog", "\U000F0591"},
            {"hail", "\U000F0592"},
            {"lightning", "\U000F0593"},
            {"lightning-rainy", "\U000F067E"},
            {"partlycloudy", "\U000F0595"},
            {"pouring", "\U000F0596"},
            {"rainy", "\U000F0597"},
            {"snowy", "\U000F0598"},
            {"snowy-rainy", "\U000F067F"},
            {"sunny", "\U000F0599"},
            {"windy", "\U000F059D"},
            {"windy-variant", "\U000F059E"},
            {"exceptional", ""},
            {"", ""}
          };

          // Get current date/time components
          int current_day = id(esptime).now().day_of_week;
          int current_month = id(esptime).now().month;
          int day_of_month = id(esptime).now().day_of_month;

          // === Section 1: Date and Time Header ===
          it.printf(id(x)[16], id(y)[1], id(font_date), id(my_gray), TextAlign::CENTER, "%s %i %s %02i:%02i", id(day_names)[current_day], day_of_month, id(month_names)[current_month], id(esptime).now().hour, id(esptime).now().minute);

          // === Section 2: Current Weather Icon ===
          std::string weather_state = id(weather_condition).state;
          image::Image *icon_img = image_dict.count(weather_state) ? image_dict.at(weather_state) : image_dict.at("");
          const char *desc_str = condition_dict.count(weather_state) ? condition_dict.at(weather_state) : "Unknown";
          it.image(id(x)[16], id(y)[5], icon_img, ImageAlign::CENTER);

          // === Section 3: Temperature Display (Outdoor / Indoor) ===
          if (id(weather_location).has_state()) {
            it.printf(id(x)[4], 0, id(font_location), id(my_blue), TextAlign::TOP_CENTER, "%s", id(weather_location).state.c_str());
          }
          if (id(weather_temperature).has_state()) {
            it.printf(id(x)[4], id(y)[1], id(font_temp), id(my_blue), TextAlign::TOP_CENTER, "%.0f°", id(weather_temperature).state);
          }
          if (id(temp_int).has_state()) {
            it.printf(id(x)[27], 0, id(font_location), id(my_red), TextAlign::TOP_CENTER, "In Casa");
            it.printf(id(x)[27], id(y)[1], id(font_temp), id(my_red), TextAlign::TOP_CENTER, "%.0f°", id(temp_int).state);
          }

          // === Section 4: Environmental Sensors (Humidity, Wind, Pressure) ===
          if (id(umidita_ext).has_state()) {
            it.printf(id(x)[4], id(y)[5], id(sensor_font), TextAlign::TOP_CENTER, "\U000F058E %.0f%%", id(umidita_ext).state);
          }
          if (id(umidita_int).has_state()) {
            it.printf(id(x)[27], id(y)[5], id(sensor_font), TextAlign::TOP_CENTER, "\U000F058E %.0f%%", id(umidita_int).state);
          }
          if (id(vento).has_state()) {
            it.printf(id(x)[4], id(y)[7], id(sensor_font), TextAlign::CENTER, "\U000F059D %.0f km/h", id(vento).state);
          }
          if (id(pressione_int).has_state()) {
            it.printf(id(x)[27], id(y)[7], id(sensor_font), TextAlign::CENTER, "\U000F04C5 %.0fb", id(pressione_int).state);
          }

          // === Section 5: Separator Line ===
          it.line(0, id(y)[8], id(x)[32], id(y)[8], Color::WHITE);

          // === Section 6: 5-Day Weather Forecast ===
          int forecast_day = current_day + 1;
          if (forecast_day == 8) forecast_day = 1;

          for (int i = 1; i <= 5; ++i) {
            std::string condition = id(forecast_condition)[i];
            float precipitation   = id(forecast_precip)[i];
            float temp_max        = id(forecast_temp_max)[i];
            float temp_min        = id(forecast_temp_min)[i];

            // Day name
            it.printf(id(x_forecast)[i], id(y)[9], id(font_day), id(my_green), TextAlign::CENTER, "%s", day_array_ext[forecast_day]);

            // Weather icon
            if (icon_dict.count(condition) > 0) {
              it.printf(id(x_forecast)[i], id(y)[12], id(symbols_font), TextAlign::CENTER, "%s", icon_dict.at(condition));
            }

            // Temperature range and precipitation
            it.printf(id(x_forecast)[i], id(y)[15], id(font_forecast), TextAlign::CENTER, "%.0f°|%.0f°", temp_min, temp_max);
            it.printf(id(x_forecast)[i], id(y)[16], id(font_forecast), TextAlign::CENTER, "%.0f mm", precipitation);

            forecast_day += 1;
            if (forecast_day == 8) forecast_day = 1;
          }

          // === Section 7: Separator Line ===
          it.line(0, id(y)[17], id(x)[32], id(y)[17], Color::WHITE);

          // === Section 8: Thermostat Status ===
          if (id(termostato1).mode == climate::CLIMATE_MODE_OFF) {
            it.printf(id(x_forecast)[3], id(y)[20], id(symbols_font), id(my_gray), TextAlign::CENTER, "\U000F0425");
          } else {
            if (id(sensor_caldaia).state) {
              // Heater is active
              it.printf(id(x_forecast)[3], id(y)[20], id(symbols_font), id(my_red), TextAlign::CENTER, "\U000F0238");
            } else {
              // Heater is idle
              it.printf(id(x_forecast)[3], id(y)[20], id(symbols_font), id(my_gray), TextAlign::CENTER, "\U000F0238");
            }
          }

          // Target temperature display
          it.printf(id(x_forecast)[3], id(y)[24], id(font_location), id(my_red), TextAlign::BASELINE_CENTER, "%.1f°", id(termostato1).target_temperature);

          // === Section 9: Motion Sensor Indicator ===
          if (id(movimento).state) {
            it.printf(id(x_forecast)[5], id(y)[21], id(symbols_font), id(my_red), TextAlign::CENTER, "\U000F06D0");
            it.printf(id(x_forecast)[1],  id(y)[21], id(symbols_font), id(my_red), TextAlign::CENTER,  "\U000F06D0");
          } else {
            it.printf(id(x_forecast)[5], id(y)[21], id(symbols_font), id(my_gray), TextAlign::CENTER, "\U000F0415");
            it.printf(id(x_forecast)[1],  id(y)[21], id(symbols_font), id(my_gray), TextAlign::CENTER,  "\U000F0374");
          }

          // === Section 10: Total Power Consumption ===
          if (id(consumo_t).has_state()) {
            int icona_x = id(x)[6];
            if (id(consumo_t).state < 2800) {
              // Normal consumption (below threshold)
              it.printf(id(x_forecast)[2], id(y)[20], id(symbols_font), id(my_gray), TextAlign::CENTER, "\U000F0241");
              it.printf(id(x_forecast)[2], id(y)[24], id(font_location), id(my_blue), TextAlign::BASELINE_CENTER, "%.0f W", id(consumo_t).state);
            } else {
              // High consumption warning
              it.printf(id(x_forecast)[2], id(y)[20], id(symbols_font), id(my_red), TextAlign::CENTER, "\U000F0241");
              it.printf(id(x_forecast)[2], id(y)[24], id(font_location), id(my_red), TextAlign::BASELINE_CENTER, "%.0f W", id(consumo_t).state);
            }
          }

          // === Section 11: Secondary Power Consumption (Washing Machine) ===
          if (id(consumo_c).has_state()) {
            int icona_x = id(x)[18];
            if (id(consumo_c).state > 20) {
              // Appliance is running
              it.printf(id(x_forecast)[4], id(y)[20], id(symbols_font), id(my_red), TextAlign::CENTER, "\U000F072A");
              it.printf(id(x_forecast)[4], id(y)[24], id(font_location), id(my_red), TextAlign::BASELINE_CENTER, "%.0f W", id(consumo_c).state);
            } else {
              // Appliance is off
              it.printf(id(x_forecast)[4], id(y)[20], id(symbols_font), id(my_gray), TextAlign::CENTER, "\U000F11BD");
              it.printf(id(x_forecast)[4], id(y)[24], id(font_location), id(my_blue), TextAlign::BASELINE_CENTER, "%.0f W", id(consumo_c).state);
            }
          }

      # -----------------------------------------------------------------------
      # Alarm Control Panel Page
      # -----------------------------------------------------------------------
      # Touch interface for Home Assistant alarm control.
      # Left side: Control buttons (Arm Home, Arm Away, Disarm)
      # Right side: Current alarm status with icon

      - id: alarm_cp_page
        lambda: |-
          it.filled_rectangle(0, 0, it.get_width(), it.get_height(), Color::BLACK);
          it.filled_rectangle(0, 0, it.get_width()/2, it.get_height(), id(my_gray));
          it.rectangle(0, 0, it.get_width(), it.get_height(), Color::WHITE);
          it.line(it.get_width()/2, 0, it.get_width()/2, it.get_height(), Color::WHITE);

          // Alarm control button labels (Italian)
          const char *left_texts[] = {
            "Attiva in casa",       // Arm Home
            "Attiva fuori casa",    // Arm Away
            "Disattiva",            // Disarm
          };
          const int num_sections = 3;
          const int section_height = it.get_height() / num_sections;
          int left_center_x = it.get_width() / 4;

          // Draw button labels and dividers
          for (int i = 0; i < num_sections; i++) {
            int text_y = section_height * i + section_height / 2;
            it.printf(left_center_x, text_y, id(font_location), TextAlign::CENTER, left_texts[i]);
            if (i < num_sections - 1) {
              int line_y = section_height * (i + 1);
              it.line(0, line_y, it.get_width()/2, line_y, Color::WHITE);
            }
          }

          // Alarm state to icon mapping
          static const std::map<std::string, const char *> alarm_icon_dict = {
            {"armed_away", "\U000F099D"},
            {"armed_home", "\U000F068A"},
            {"armed_custom_bypass", "\U000F0780"},
            {"disarmed", "\U000F099E"},
            {"anomaly", "\U000F0ECC"},
            {"", "\U000F0ECC"}
          };

          // Alarm state to localized description mapping (Italian)
          static const std::map<std::string, const char *> alarm_text_dict = {
            {"armed_away", "Fuori casa"},
            {"armed_home", "Dentro casa"},
            {"armed_custom_bypass", "Bypass"},
            {"disarmed", "Disarmato"},
            {"anomaly", "Anomalia"},
            {"arming", "In attivazione"},
            {"", "Sconosciuto"}
          };

          // Get current alarm state and lookup display values
          std::string alarm_state = id(stato_allarme).state;
          const char *alarm_icon = alarm_icon_dict.count(alarm_state)
                                   ? alarm_icon_dict.at(alarm_state)
                                   : alarm_icon_dict.at("");
          const char *alarm_text = alarm_text_dict.count(alarm_state)
                                   ? alarm_text_dict.at(alarm_state)
                                   : "Unknown State";

          // Determine status color based on alarm state
          Color alarm_color = Color::WHITE;
          if (alarm_state == "armed_away" || alarm_state == "anomaly") {
            alarm_color = id(my_red);
          } else if (alarm_state == "armed_home") {
            alarm_color = id(my_yellow);
          } else if (alarm_state == "armed_custom_bypass") {
            alarm_color = id(my_blue);
          } else if (alarm_state == "arming") {
            alarm_color = id(my_yellow);
          }

          // Display alarm status icon and text on right side
          int icon_x = it.get_width() * 3 / 4;
          int icon_y = it.get_height() / 2 - 20;
          it.printf(icon_x, icon_y, id(symbols_font), alarm_color, TextAlign::CENTER, alarm_icon);

          int text_y = icon_y + 30;
          it.printf(icon_x, text_y, id(font_location), alarm_color, TextAlign::CENTER, alarm_text);
